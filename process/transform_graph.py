import gzip
import json
import logging
from pathlib import Path

# === Configuration for Logging ===
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Define Paths ---
# Adjust these paths according to where you run this script relative to your project structure.
# Assuming 'docs' is a sibling directory to where your 'process' directory resides,
# and this script is, for example, within 'process/geo'.
# If you run this script from the project root, you might adjust 'parent.parent'.
docs_directory = Path(__file__).resolve().parent.parent / "docs" # Adjust as needed
geo_output_directory = docs_directory / "data" / "geo"

# Original graph generated by sea_routes.py
# Make sure this matches the output path in sea_routes.py
INPUT_GRAPH_PATH = geo_output_directory / "sea_graph_uk.json.gz"

# New graph file name for the transformed data
# This is the file your frontend JavaScript will now fetch
OUTPUT_GRAPH_PATH = geo_output_directory / "sea_graph_dijkstra.json.gz"

def load_original_graph(file_path: Path) -> dict:
    """Loads the gzipped JSON graph from the specified path."""
    if not file_path.exists():
        logger.error(f"Input graph file not found: {file_path}")
        raise FileNotFoundError(f"Input graph file not found at {file_path}")

    logger.info(f"Loading original graph from {file_path}...")
    try:
        # 'rt' mode for reading as text
        with gzip.open(file_path, "rt", encoding="utf-8") as f:
            graph = json.load(f)
        logger.info("Original graph loaded successfully.")
        return graph
    except Exception as e:
        logger.error(f"Error loading original graph: {e}")
        raise

def transform_graph_format(original_graph: dict) -> dict:
    """
    Transforms the graph format from:
    {"node_id": [["neighbor_id", weight], ...]}
    to the format expected by dijkstrajs:
    {"node_id": {"neighbor_id": weight, ...}}
    """
    logger.info("Transforming graph format...")
    transformed_graph = {}
    for node_id, edges in original_graph.items():
        transformed_graph[node_id] = {}
        for neighbor_id, weight in edges:
            transformed_graph[node_id][neighbor_id] = weight
    logger.info("Graph transformation complete.")
    return transformed_graph

def save_transformed_graph(transformed_graph: dict, file_path: Path):
    """Saves the transformed graph to a gzipped JSON file."""
    logger.info(f"Saving transformed graph to {file_path}...")
    try:
        # Ensure the directory exists
        file_path.parent.mkdir(parents=True, exist_ok=True)
        # 'wt' mode for writing as text
        with gzip.open(file_path, "wt", encoding="utf-8") as f:
            json.dump(transformed_graph, f, separators=(",", ":")) # compact JSON for efficiency
        logger.info(f"Transformed graph saved successfully to {file_path}")
    except Exception as e:
        logger.error(f"Error saving transformed graph: {e}")
        raise

def main():
    """Main function to orchestrate graph loading, transformation, and saving."""
    logger.info("Starting graph transformation process.")
    try:
        original_graph = load_original_graph(INPUT_GRAPH_PATH)
        transformed_graph = transform_graph_format(original_graph)
        save_transformed_graph(transformed_graph, OUTPUT_GRAPH_PATH)
        logger.info("Graph transformation process finished successfully.")
    except Exception as e:
        logger.critical(f"Graph transformation failed: {e}")

if __name__ == "__main__":
    main()